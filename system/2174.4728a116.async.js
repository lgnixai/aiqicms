!(function(){"use strict";var W=(p,S,w)=>new Promise((m,b)=>{var g=y=>{try{T(w.next(y))}catch(B){b(B)}},i=y=>{try{T(w.throw(y))}catch(B){b(B)}},T=y=>y.done?m(y.value):Promise.resolve(y.value).then(g,i);T((w=w.apply(p,S)).next())});(self.webpackChunkAnQiCMS=self.webpackChunkAnQiCMS||[]).push([[2174],{50442:function(p,S,w){w.d(S,{c:function(){return T}});var m=w(71180),b=w(25043),g=w(55247),i=w(65377);function T(h){var v={options:{directed:h.isDirected(),multigraph:h.isMultigraph(),compound:h.isCompound()},nodes:y(h),edges:B(h)};return m.Z(h.graph())||(v.value=b.Z(h.graph())),v}function y(h){return g.Z(h.nodes(),function(v){var E=h.node(v),C=h.parent(v),M={v};return m.Z(E)||(M.value=E),m.Z(C)||(M.parent=C),M})}function B(h){return g.Z(h.edges(),function(v){var E=h.edge(v),C={v:v.v,w:v.w};return m.Z(v.name)||(C.name=v.name),m.Z(E)||(C.value=E),C})}function o(h){var v=new Graph(h.options).setGraph(h.value);return _.each(h.nodes,function(E){v.setNode(E.v,E.value),E.parent&&v.setParent(E.v,E.parent)}),_.each(h.edges,function(E){v.setEdge({v:E.v,w:E.w,name:E.name},E.value)}),v}},25043:function(p,S,w){var m=w(85811),b=4;function g(i){return(0,m.Z)(i,b)}S.Z=g},32174:function(p,S,w){w.d(S,{r:function(){return Q}});var m=w(62799),b=w(50442),g=w(36869),i=w(82725),T=w(42521),y=w(51371),B=w(15525);let o={},h={},v={};const E=()=>{h={},v={},o={}},C=(n,t)=>(i.l.trace("In isDescendant",t," ",n," = ",h[t].includes(n)),!!h[t].includes(n)),M=(n,t)=>(i.l.info("Descendants of ",t," is ",h[t]),i.l.info("Edge is ",n),n.v===t||n.w===t?!1:h[t]?h[t].includes(n.v)||C(n.v,t)||C(n.w,t)||h[t].includes(n.w):(i.l.debug("Tilt, ",t,",not in descendants"),!1)),J=(n,t,e,r)=>{i.l.warn("Copying children of ",n,"root",r,"data",t.node(n),r);const s=t.children(n)||[];n!==r&&s.push(n),i.l.warn("Copying (nodes) clusterId",n,"nodes",s),s.forEach(l=>{if(t.children(l).length>0)J(l,t,e,r);else{const f=t.node(l);i.l.info("cp ",l," to ",r," with parent ",n),e.setNode(l,f),r!==t.parent(l)&&(i.l.warn("Setting parent",l,t.parent(l)),e.setParent(l,t.parent(l))),n!==r&&l!==n?(i.l.debug("Setting parent",l,n),e.setParent(l,n)):(i.l.info("In copy ",n,"root",r,"data",t.node(n),r),i.l.debug("Not Setting parent for node=",l,"cluster!==rootId",n!==r,"node!==clusterId",l!==n));const u=t.edges(l);i.l.debug("Copying Edges",u),u.forEach(d=>{i.l.info("Edge",d);const x=t.edge(d.v,d.w,d.name);i.l.info("Edge data",x,r);try{M(d,r)?(i.l.info("Copying as ",d.v,d.w,x,d.name),e.setEdge(d.v,d.w,x,d.name),i.l.info("newGraph edges ",e.edges(),e.edge(e.edges()[0]))):i.l.info("Skipping copy of edge ",d.v,"-->",d.w," rootId: ",r," clusterId:",n)}catch(D){i.l.error(D)}})}i.l.debug("Removing node",l),t.removeNode(l)})},K=(n,t)=>{const e=t.children(n);let r=[...e];for(const s of e)v[s]=n,r=[...r,...K(s,t)];return r},L=(n,t)=>{i.l.trace("Searching",n);const e=t.children(n);if(i.l.trace("Searching children of id ",n,e),e.length<1)return i.l.trace("This is a valid node",n),n;for(const r of e){const s=L(r,t);if(s)return i.l.trace("Found replacement for",n," => ",s),s}},A=n=>!o[n]||!o[n].externalConnections?n:o[n]?o[n].id:n,G=(n,t)=>{if(!n||t>10){i.l.debug("Opting out, no graph ");return}else i.l.debug("Opting in, graph ");n.nodes().forEach(function(e){n.children(e).length>0&&(i.l.warn("Cluster identified",e," Replacement id in edges: ",L(e,n)),h[e]=K(e,n),o[e]={id:L(e,n),clusterData:n.node(e)})}),n.nodes().forEach(function(e){const r=n.children(e),s=n.edges();r.length>0?(i.l.debug("Cluster identified",e,h),s.forEach(l=>{if(l.v!==e&&l.w!==e){const f=C(l.v,e),u=C(l.w,e);f^u&&(i.l.warn("Edge: ",l," leaves cluster ",e),i.l.warn("Descendants of XXX ",e,": ",h[e]),o[e].externalConnections=!0)}})):i.l.debug("Not a cluster ",e,h)});for(let e of Object.keys(o)){const r=o[e].id,s=n.parent(r);s!==e&&o[s]&&!o[s].externalConnections&&(o[e].id=s)}n.edges().forEach(function(e){const r=n.edge(e);i.l.warn("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(e)),i.l.warn("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(n.edge(e)));let s=e.v,l=e.w;if(i.l.warn("Fix XXX",o,"ids:",e.v,e.w,"Translating: ",o[e.v]," --- ",o[e.w]),o[e.v]&&o[e.w]&&o[e.v]===o[e.w]){i.l.warn("Fixing and trixing link to self - removing XXX",e.v,e.w,e.name),i.l.warn("Fixing and trixing - removing XXX",e.v,e.w,e.name),s=A(e.v),l=A(e.w),n.removeEdge(e.v,e.w,e.name);const f=e.w+"---"+e.v;n.setNode(f,{domId:f,id:f,labelStyle:"",labelText:r.label,padding:0,shape:"labelRect",style:""});const u=structuredClone(r),d=structuredClone(r);u.label="",u.arrowTypeEnd="none",d.label="",u.fromCluster=e.v,d.toCluster=e.v,n.setEdge(s,f,u,e.name+"-cyclic-special"),n.setEdge(f,l,d,e.name+"-cyclic-special")}else if(o[e.v]||o[e.w]){if(i.l.warn("Fixing and trixing - removing XXX",e.v,e.w,e.name),s=A(e.v),l=A(e.w),n.removeEdge(e.v,e.w,e.name),s!==e.v){const f=n.parent(s);o[f].externalConnections=!0,r.fromCluster=e.v}if(l!==e.w){const f=n.parent(l);o[f].externalConnections=!0,r.toCluster=e.w}i.l.warn("Fix Replacing with XXX",s,l,e.name),n.setEdge(s,l,r,e.name)}}),i.l.warn("Adjusted Graph",b.c(n)),j(n,0),i.l.trace(o)},j=(n,t)=>{if(i.l.warn("extractor - ",t,b.c(n),n.children("D")),t>10){i.l.error("Bailing out");return}let e=n.nodes(),r=!1;for(const s of e){const l=n.children(s);r=r||l.length>0}if(!r){i.l.debug("Done, no node has children",n.nodes());return}i.l.debug("Nodes = ",e,t);for(const s of e)if(i.l.debug("Extracting node",s,o,o[s]&&!o[s].externalConnections,!n.parent(s),n.node(s),n.children("D")," Depth ",t),!o[s])i.l.debug("Not a cluster",s,t);else if(!o[s].externalConnections&&n.children(s)&&n.children(s).length>0){i.l.warn("Cluster without external connections, without a parent and with children",s,t);let f=n.graph().rankdir==="TB"?"LR":"TB";o[s]&&o[s].clusterData&&o[s].clusterData.dir&&(f=o[s].clusterData.dir,i.l.warn("Fixing dir",o[s].clusterData.dir,f));const u=new T.k({multigraph:!0,compound:!0}).setGraph({rankdir:f,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});i.l.warn("Old graph before copy",b.c(n)),J(s,n,u,s),n.setNode(s,{clusterNode:!0,id:s,clusterData:o[s].clusterData,labelText:o[s].labelText,graph:u}),i.l.warn("New graph after copy node: (",s,")",b.c(u)),i.l.debug("Old graph after copy",b.c(n))}else i.l.warn("Cluster ** ",s," **not meeting the criteria !externalConnections:",!o[s].externalConnections," no parent: ",!n.parent(s)," children ",n.children(s)&&n.children(s).length>0,n.children("D"),t),i.l.debug(o);e=n.nodes(),i.l.warn("New list of nodes",e);for(const s of e){const l=n.node(s);i.l.warn(" Now next level",s,l),l.clusterNode&&j(l.graph,t+1)}},U=(n,t)=>{if(t.length===0)return[];let e=Object.assign(t);return t.forEach(r=>{const s=n.children(r),l=U(n,s);e=[...e,...l]}),e},k=n=>U(n,n.children()),$={rect:(n,t)=>{i.l.info("Creating subgraph rect for ",t.id,t);const e=(0,i.c)(),r=n.insert("g").attr("class","cluster"+(t.class?" "+t.class:"")).attr("id",t.id),s=r.insert("rect",":first-child"),l=(0,i.m)(e.flowchart.htmlLabels),f=r.insert("g").attr("class","cluster-label"),u=t.labelType==="markdown"?(0,y.a)(f,t.labelText,{style:t.labelStyle,useHtmlLabels:l}):f.node().appendChild((0,g.c)(t.labelText,t.labelStyle,void 0,!0));let d=u.getBBox();if((0,i.m)(e.flowchart.htmlLabels)){const c=u.children[0],a=(0,B.Ys)(u);d=c.getBoundingClientRect(),a.attr("width",d.width),a.attr("height",d.height)}const x=0*t.padding,D=x/2,O=t.width<=d.width+x?d.width+x:t.width;t.width<=d.width+x?t.diff=(d.width-t.width)/2-t.padding/2:t.diff=-t.padding/2,i.l.trace("Data ",t,JSON.stringify(t)),s.attr("style",t.style).attr("rx",t.rx).attr("ry",t.ry).attr("x",t.x-O/2).attr("y",t.y-t.height/2-D).attr("width",O).attr("height",t.height+x);const{subGraphTitleTopMargin:X}=(0,g.g)(e);l?f.attr("transform",`translate(${t.x-d.width/2}, ${t.y-t.height/2+X})`):f.attr("transform",`translate(${t.x}, ${t.y-t.height/2+X})`);const N=s.node().getBBox();return t.width=N.width,t.height=N.height,t.intersect=function(c){return(0,g.i)(t,c)},r},roundedWithTitle:(n,t)=>{const e=(0,i.c)(),r=n.insert("g").attr("class",t.classes).attr("id",t.id),s=r.insert("rect",":first-child"),l=r.insert("g").attr("class","cluster-label"),f=r.append("rect"),u=l.node().appendChild((0,g.c)(t.labelText,t.labelStyle,void 0,!0));let d=u.getBBox();if((0,i.m)(e.flowchart.htmlLabels)){const c=u.children[0],a=(0,B.Ys)(u);d=c.getBoundingClientRect(),a.attr("width",d.width),a.attr("height",d.height)}d=u.getBBox();const x=0*t.padding,D=x/2,O=t.width<=d.width+t.padding?d.width+t.padding:t.width;t.width<=d.width+t.padding?t.diff=(d.width+t.padding*0-t.width)/2:t.diff=-t.padding/2,s.attr("class","outer").attr("x",t.x-O/2-D).attr("y",t.y-t.height/2-D).attr("width",O+x).attr("height",t.height+x),f.attr("class","inner").attr("x",t.x-O/2-D).attr("y",t.y-t.height/2-D+d.height-1).attr("width",O+x).attr("height",t.height+x-d.height-3);const{subGraphTitleTopMargin:X}=(0,g.g)(e);l.attr("transform",`translate(${t.x-d.width/2}, ${t.y-t.height/2-t.padding/3+((0,i.m)(e.flowchart.htmlLabels)?5:3)+X})`);const N=s.node().getBBox();return t.height=N.height,t.intersect=function(c){return(0,g.i)(t,c)},r},noteGroup:(n,t)=>{const e=n.insert("g").attr("class","note-cluster").attr("id",t.id),r=e.insert("rect",":first-child"),s=0*t.padding,l=s/2;r.attr("rx",t.rx).attr("ry",t.ry).attr("x",t.x-t.width/2-l).attr("y",t.y-t.height/2-l).attr("width",t.width+s).attr("height",t.height+s).attr("fill","none");const f=r.node().getBBox();return t.width=f.width,t.height=f.height,t.intersect=function(u){return(0,g.i)(t,u)},e},divider:(n,t)=>{const e=n.insert("g").attr("class",t.classes).attr("id",t.id),r=e.insert("rect",":first-child"),s=0*t.padding,l=s/2;r.attr("class","divider").attr("x",t.x-t.width/2-l).attr("y",t.y-t.height/2).attr("width",t.width+s).attr("height",t.height+s);const f=r.node().getBBox();return t.width=f.width,t.height=f.height,t.diff=-t.padding/2,t.intersect=function(u){return(0,g.i)(t,u)},e}};let Z={};const Y=(n,t)=>{i.l.trace("Inserting cluster");const e=t.shape||"rect";Z[t.id]=$[e](n,t)},H=()=>{Z={}},F=(n,t,e,r,s,l)=>W(this,null,function*(){i.l.info("Graph in recursive render: XXX",b.c(t),s);const f=t.graph().rankdir;i.l.trace("Dir in recursive render - dir:",f);const u=n.insert("g").attr("class","root");t.nodes()?i.l.info("Recursive render XXX",t.nodes()):i.l.info("No nodes found for",t),t.edges().length>0&&i.l.trace("Recursive edges",t.edge(t.edges()[0]));const d=u.insert("g").attr("class","clusters"),x=u.insert("g").attr("class","edgePaths"),D=u.insert("g").attr("class","edgeLabels"),O=u.insert("g").attr("class","nodes");yield Promise.all(t.nodes().map(function(c){return W(this,null,function*(){const a=t.node(c);if(s!==void 0){const P=JSON.parse(JSON.stringify(s.clusterData));i.l.info("Setting data for cluster XXX (",c,") ",P,s),t.setNode(s.id,P),t.parent(c)||(i.l.trace("Setting parent",c,s.id),t.setParent(c,s.id,P))}if(i.l.info("(Insert) Node XXX"+c+": "+JSON.stringify(t.node(c))),a&&a.clusterNode){i.l.info("Cluster identified",c,a.width,t.node(c));const P=yield F(O,a.graph,e,r,t.node(c),l),R=P.elem;(0,g.u)(a,R),a.diff=P.diff||0,i.l.info("Node bounds (abc123)",c,a,a.width,a.x,a.y),(0,g.s)(R,a),i.l.warn("Recursive render complete ",R,a)}else t.children(c).length>0?(i.l.info("Cluster - the non recursive path XXX",c,a.id,a,t),i.l.info(L(a.id,t)),o[a.id]={id:L(a.id,t),node:a}):(i.l.info("Node - the non recursive path",c,a.id,a),yield(0,g.e)(O,t.node(c),f))})})),t.edges().forEach(function(c){const a=t.edge(c.v,c.w,c.name);i.l.info("Edge "+c.v+" -> "+c.w+": "+JSON.stringify(c)),i.l.info("Edge "+c.v+" -> "+c.w+": ",c," ",JSON.stringify(t.edge(c))),i.l.info("Fix",o,"ids:",c.v,c.w,"Translating: ",o[c.v],o[c.w]),(0,g.f)(D,a)}),t.edges().forEach(function(c){i.l.info("Edge "+c.v+" -> "+c.w+": "+JSON.stringify(c))}),i.l.info("#############################################"),i.l.info("###                Layout                 ###"),i.l.info("#############################################"),i.l.info(t),(0,m.bK)(t),i.l.info("Graph after layout:",b.c(t));let X=0;const{subGraphTitleTotalMargin:N}=(0,g.g)(l);return k(t).forEach(function(c){const a=t.node(c);i.l.info("Position "+c+": "+JSON.stringify(t.node(c))),i.l.info("Position "+c+": ("+a.x,","+a.y,") width: ",a.width," height: ",a.height),a&&a.clusterNode?(a.y+=N,(0,g.p)(a)):t.children(c).length>0?(a.height+=N,Y(d,a),o[a.id].node=a):(a.y+=N/2,(0,g.p)(a))}),t.edges().forEach(function(c){const a=t.edge(c);i.l.info("Edge "+c.v+" -> "+c.w+": "+JSON.stringify(a),a),a.points.forEach(R=>R.y+=N/2);const P=(0,g.h)(x,c,a,o,e,t,r);(0,g.j)(a,P)}),t.nodes().forEach(function(c){const a=t.node(c);i.l.info(c,a.type,a.diff),a.type==="group"&&(X=a.diff)}),{elem:u,diff:X}}),Q=(n,t,e,r,s)=>W(this,null,function*(){(0,g.a)(n,e,r,s),(0,g.b)(),(0,g.d)(),H(),E(),i.l.warn("Graph at first:",JSON.stringify(b.c(t))),G(t),i.l.warn("Graph after:",JSON.stringify(b.c(t)));const l=(0,i.c)();yield F(n,t,r,s,void 0,l)})}}]);
}());